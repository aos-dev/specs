---
author: xxchan <xxchan22f@gmail.com>
status: draft
updated_at: 2020-05-03
---

# AOS-xx: Better Error Handling

## Background

### AOS-11

`11-error-handling` proposed that in the top level, [go-storage] should return custom error `struct`s carrying contextual errors. Specifically, the `struct`s will have the following definitions:

```go
type SomeError struct {
	Op  string
	Err error

	ContextA string
	ContextB structB
	...
}
```

The `Err` field wraps the cause of the error. 
- For unexpected error, it will be wrapped directly. 
- For expected error, the related error should be used directly. However, it is not strictly specified how to define and use expected errors. 

### Current Practice

Currently, the error handling mechanism in [go-storage] can be summarized as below:

- top-level: `InitError`, `ServiceError` and `StorageError`
	- defined in [go-storage/services/error.go]
	- have `Op`, `Err` and context fields
	- returned in `defer` in `go-service-*`s' public APIs
		- Public APIs in `generated.go` (generated by `service.tmpl`) call `s.formatError` in `defer`. So the implementor should implement `formatError` method for `Storage` (and `Service` maybe) where `StorageError` (or `ServiceError`) is returned.
		- For other handwritten public APIs like `New`, the implementor should similarly return a top-level error like `InitError`.
	- They are orthogonal (won't wrap each other).

- middle-level: `MetadataUnrecognizedError`, `PairUnsupportedError`, `PairRequiredError`
	- wrapped by top-level errors
	- defined in [go-storage/services/error.go]
	- have `Err` and context fields, don't have `Op`
	- returned in `go-service-*` by generated parse functions and handwritten `new` functions

- bottom-level: the most deeply wrapped error
	- wrapped by top-level or intermediate-level errors
	- are either 
		- from SDKs: `*googleapi.Error`, `*qserror.QingStorError`, ...
		- sentinel errors: 
			- `var ErrSomethingWrong = errors.New("what happened")`
			- defined in either [go-storage/services/error.go] or `go-service-*/error.go`
		- ad-hoc string errors: `errors.New()` or `fmt.Errorf()` without `%w` verb wrapping an error inside

And correspondingly, the lifetime of an error is:
1. Returned by SDK as a SDK error.
2. Converted into a sentinel error or an ad-hoc string error if it is what we expected. Otherwise, kept as it is.
3. Wrapped into one or more layers of error `struct`s 

### Problems

#### Nonunified bottom-level errors

The bottom-level errors are the really cause of the errors, so it will be good if they can enable users to identify and handle errors more easily. But now they can't.

1. Ad-hoc string errors are not user-friendly. The user cannot use `errors.Is` & `errors.As` to handle such errors specially.
2. Wrapping (partial) SDK errors will lead to abstraction leak. In terms of error handling, being vendor agnostic means we should provide a unified custom error to hide the SDK errors, e.g., we convert some SDK errors into our `ErrObjectNotExist`. However, unexpected errors will be wrapped directly. It is possible that users use `errors.Is` & `errors.As` targeting SDK errors. Then problems will come when we add a new kind of expected error and convert some SDK errors into it. It may be confusing that some SDK errors are wrapped, while the others are not. Below is an example of such partial conversion.

```go
func formatError(err error) error {
	e, ok := err.(awserr.RequestFailure)
	if !ok {
		return err
	}

	switch e.Code() {
	// AWS SDK will use status code to generate awserr.Error, so "NotFound" should also be supported.
	case "NoSuchKey", "NotFound":
		return fmt.Errorf("%w: %v", services.ErrObjectNotExist, err)
	case "AccessDenied":
		return fmt.Errorf("%w: %v", services.ErrPermissionDenied, err)
	// What if we add a new case, but users already handle it themselves?
	}

	return err
}
```
#### Unclear error layers

`11-error-handling` is not detailed enough. It talked about expected and unexpected errors, but not the error layers. Below are not clear:

1. There exist mid-level contextual errors wrapped by top-level contextual errors, and mid-level errors do not have `Op`.
2. It is not specified how to define bottom-level expected errors.


As a result, both users and implementors may be confused which kind of error should be returned at which place.

## Proposal

So I propose the following error handling specification as a supplement of `11-error-handling`:

1. Public APIs SHOULD return top-level errors, which MUST be defined as below:
	```go
	type SomeError struct {
		Op  string
		Err error

		ContextA string
		ContextB structB
		...
	}
	```
2. The bottom-level (most deeply wrapped) errors MUST be either:
   - sentinel errors defined somewhere, if it is an expected error.
   - `fmt.Errorf("%v", err)`, if it is an unexpected error. SDK errors are NEVER wrapped.
3. There CAN be zero or more middle-level errors between top-level and bottom-level errors, which MUST be defined as below:
	```go
	type SomeError struct {
		Err error

		ContextA string
		ContextB structB
		...
	}
	```

### Where to define expected errors

Top-level errors SHOULD be defined in [go-storage].

For other errors, if an error is related to a feature supported by service pairs, e.g., server-side encryption, it is considered a service-specific error and should be defined in `go-service-*`. Otherwise, it should be defined in [go-storage].

### Alternative 1: Single Top-level Error

Since the only difference between top-level and middle-level errors is `Op`, we can provide a single top-level `Error` type as below, and old top-level errors are turned into middle-level errors.

```go
type Error struct {
	Op string
	Err error
}
```

#### Pros

- Easier to understand the error layers.
- The user can get `Op` by `As(Error)`, instead of figuring out which top-level error it is. (But `Op` may be rare to be need elsewhere than in an error message.)

#### Cons 

- Introduce break change.
- Former top-level errors degraded to the same category as other middle-level errors. (Formerly, each of them is special.) 

### Alternative 2: Wrapping all SDK errors

Wrapping SDK errors partially is bad. Then besides never wrapping them, we can also always wrap them. 

#### Pros 

- The user can handle original SDK errors transparently with `As` & `Is`.

#### Cons

- Introduce break change: former bottom-level sentinel errors like `ErrObjectNotExist` should wrap an original error now.

## Rationale

First, it is necessary to state more clearly the current practice and turn it into a specification.

The current situation has almost reached the goal of letting users know "where" and "why" an error happens:
- The top-level errors' `Op` and their names tell users "where".
- The context fields and the wrapped error can provide rich error message, telling users "why".

But we can do more: let users handle error gracefully.Ad-hoc string error can not be handled by users, so we should ban them.

And our goal is to provide a unified user experience: define an abstract layer of errors for the users, free them of the tedium of handling similar errors from multiple SDKs.

## Compatibility

Only need to extract some ad-hoc string errors into defined sentinel errors.

## Implementation

Most of the work would be done by the author of this proposal.

[go-storage]: https://github.com/aos-dev/go-storage
[go-storage/services/error.go]: https://github.com/aos-dev/go-storage/blob/master/services/error.go