---
author: JinnyYi <github.com/JinnyYi>
status: draft
updated_at: 2021-06-09
---

# GSP-97: Add Restrictions In Storage Metadata

## Background

We use `Write` to handle single write operation. And the size is not unlimited.

- S3 alike storage services have 5GB limit for a single PUT operation.
- azblob limited to 5000 MiB for put blob (<https://docs.microsoft.com/en-us/rest/api/storageservices/put-blob>).

If we upload a file with size out of limit in a single operation, we will get an error like `Request Entity Too Large` in azblob.

Similar restriction also with `copy`,`append`, etc. We should figure out the error before sending request to reduce the consumption of network resources.

These restrictions belong to storage. Currently, we have `StorageMeta` to carry storage metadata which is generated by `go generate cmd/definitions`:

```go
type StorageMeta struct {
	location string
	Name     string
	WorkDir  string
	
	// bit used as a bitmap for object value, 0 means not set, 1 means set 
	bit uint64
	m   map[string]interface{}
}
```

But the current `StorageMeta` cannot solve the above problem:

- The fields are finite. For now, `m` is unused, and it's not convenient to hold the definite metadata.
- Services have to call `metadata` repeatedly before use storage metadata internally.

## Proposal

So I propose to add restrictions in storage metadata.

### Add global storage metadata

Add maximum size restrictions as storage metadata into [info_storage_meta.toml]

- `copy-size-maximum`: Maximum size for copy operation.
- `fetch-size-maximum`: Maximum size for fetch operation.
- `move-size-maximum`: Maximum size for move operation.
- `write-size-maximum`: Maximum size for write operation.
- `append-number-maximum`: Max append numbers in append operation.
- `append-size-maximum`: Max append size in per append operation.
- `append-total-size-maximum`: Max append total size in append operation.
- `multipart-number-maximum`: Maximum part number in multipart operation.
- `multipart-size-maximum`: Maximum part size defined by storage service.
- `multipart-size-minimum`: Minimum part size defined by storage service.

### Deprecate the Existing Storage Metadata in Object Metadata

The following append and multipart related metadata in the current object metadata, actually belongs to storage metadata, should be deprecated in object metadata.

```go
type Object struct {
	...
    // AppendNumberMaximum Max append numbers in append operation
    appendNumberMaximum int
    // AppendSizeMaximum Max append size in per append operation
    appendSizeMaximum int64
    // AppendTotalSizeMaximum Max append total size in append operation
    appendTotalSizeMaximum int64
	...
    // MultipartNumberMaximum Maximum part number in multipart operation
    multipartNumberMaximum int
    // MultipartSizeMaximum Maximum part size defined by storager
    multipartSizeMaximum int64
    // MultipartSizeMinimum Minimum part size defined by storager
    multipartSizeMinimum int64
	...
}
```


Based on above, the added storage metadata and corresponding `set/get` functions could be generated and added into `StorageMeta`.

```go
type StorageMeta struct {
	location               string
	Name                   string
	WorkDir                string
	copySizeMaximum        int64
	fetchSizeMaximum       int64
	moveSizeMaximum        int64
	writeSizeMaximum       int64
	appendNumberMaximum    int64
	appendSizeMaximum      int64
	appendTotalSizeMaximum int64
	multipartNumberMaximum int64
	multipartSizeMaximum   int64
	multipartSizeMinimum   int64
	
	// bit used as a bitmap for object value, 0 means not set, 1 means set 
	bit uint64
	m   map[string]interface{}
}
```

For services:
- A member with type `StorageMeta` SHOULD be added, and the separate fields should be removed in `Storage`, like the following.
- The storage metadata `sm` should be initiated at the time the storager initiated.

```go
type Storage struct {
	sm           StorageMeta
	
	defaultPairs DefaultStoragePairs
	features     StorageFeatures
	
	typ.UnimplementedStorager
	...
}
```

## Rationale

### Alternative Way: Ignore size limit

The alternative way is to send request directly without size check and get an error when the `size` larger than the limit.

This will need invalid request and get the ambiguous error.

## Compatibility

This change will break all services.

## Implementation

- `specs`:
  - Add storage meta in [info_storage_meta.toml].
  - Add deprecate mark at the global append and multipart related meta in [info_object_meta.toml].
- `go-storage`
  - Generate the added storage metadata and corresponding `get/set` functions into `StorageMeta`.
  - Add comments start with `Deprecated` at the deprecated object metadata in generate template.
- `go-service-*`
   - Add a member with type `StorageMeta` in `Storage` and assign it on initialization.
   - Check `size` for write related operations and return `ErrRestrictionDissatisfied` when `size` out of limit.

[info_storage_meta.toml]: ../definitions/info_storage_meta.toml
[info_object_meta.toml]: ../definitions/info_object_meta.toml
